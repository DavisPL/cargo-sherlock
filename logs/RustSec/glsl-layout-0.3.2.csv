************************************
event,timestamp,label
RustSec,-,Critical
************************************
event,timestamp,organization,type,criteria,delta,version,notes
************************************
event,timestamp,name,username,url
Author,-,Zakarum,zakarumych,https://github.com/zakarumych
************************************
event,timestamp,downloads
Downloads,-,227952
************************************
event,timestamp,total,flagged
Side Effects,-,1,1
************************************
Rudra,timestamp
"2024-06-21 17:28:26.483287 |INFO | [rudra-progress] Running cargo rudra
2024-06-21 17:28:30.042143 |INFO | [rudra-progress] Running rudra for target lib:glsl-layout
[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m195[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(000);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: `#[warn(deprecated)]` on by default[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m195[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(000);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m195[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(000);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m196[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(001);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m196[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(001);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m196[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(001);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m197[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(002);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m197[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(002);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m197[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(002);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m198[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(003);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m198[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(003);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m198[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(003);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m199[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(004);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m199[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(004);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m199[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(004);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m200[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(005);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m200[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(005);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m200[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(005);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m201[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(006);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m201[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(006);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m201[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(006);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m202[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(007);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m202[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(007);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m202[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(007);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m203[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(008);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m203[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(008);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m203[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(008);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m204[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(009);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m204[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(009);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m204[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(009);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m205[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(010);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m205[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(010);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m205[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(010);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m206[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(011);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m206[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(011);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m206[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(011);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m207[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(012);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m207[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(012);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m207[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(012);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m208[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(013);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m208[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(013);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m208[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(013);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m209[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(014);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m209[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(014);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m209[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(014);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m210[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(015);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m210[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(015);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m210[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(015);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m211[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(016);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m211[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(016);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m211[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(016);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m212[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(017);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m212[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(017);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m212[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(017);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m213[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(018);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m213[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(018);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m213[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(018);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m214[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(019);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m214[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(019);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m214[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(019);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m215[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(020);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m215[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(020);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m215[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(020);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m216[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(021);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m216[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(021);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m216[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(021);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m217[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(022);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m217[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(022);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m217[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(022);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m218[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(023);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m218[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(023);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m218[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(023);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m219[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(024);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m219[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(024);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m219[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(024);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m220[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(025);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m220[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(025);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m220[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(025);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m221[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(026);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m221[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(026);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m221[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(026);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m222[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(027);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m222[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(027);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m222[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(027);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m223[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(028);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m223[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(028);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m223[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(028);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m224[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(029);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m224[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(029);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m224[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(029);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m225[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(030);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m225[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(030);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m225[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(030);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m226[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(031);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m226[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(031);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m226[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(031);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:93:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m93[0m[0m  [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m227[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(032);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:133:71[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m133[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                      [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m227[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(032);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

[0m[1m[33mwarning[0m[0m[1m: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit` instead[0m
[0m   [0m[0m[1m[38;5;12m--> [0m[0msrc/array.rs:173:70[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m[1m[38;5;12m173[0m[0m [0m[0m[1m[38;5;12m| [0m[0m                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m                                                                     [0m[0m[1m[33m^^^^^^^^^^^^^[0m
[0m[1m[38;5;12m...[0m
[0m[1m[38;5;12m227[0m[0m [0m[0m[1m[38;5;12m| [0m[0mimpl_array!(032);[0m
[0m    [0m[0m[1m[38;5;12m| [0m[0m[1m[38;5;12m----------------[0m[0m [0m[0m[1m[38;5;12min this macro invocation[0m
[0m    [0m[0m[1m[38;5;12m|[0m
[0m    [0m[0m[1m[38;5;12m= [0m[0m[1mnote[0m[0m: this warning originates in the macro `impl_array` (in Nightly builds, run with -Z macro-backtrace for more info)[0m

2024-06-21 17:28:45.555122 |INFO | [rudra-progress] Rudra started
2024-06-21 17:28:45.559497 |INFO | [rudra-progress] SendSyncVariance analysis started
2024-06-21 17:28:45.559881 |INFO | [rudra-progress] SendSyncVariance analysis finished
2024-06-21 17:28:45.559895 |INFO | [rudra-progress] UnsafeDataflow analysis started
2024-06-21 17:28:45.636569 |INFO | [rudra-progress] UnsafeDataflow analysis finished
2024-06-21 17:28:45.636598 |INFO | [rudra-progress] Rudra finished
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 18]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 0]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 29] as array::MapArray<[T; 29], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 21] as array::MapArray<[T; 21], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 27] as array::MapArray<[T; 27], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 23]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 19]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 7] as array::MapArray<[T; 7], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 26] as array::MapArray<[T; 26], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 30] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 20] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 3] as array::MapArray<[T; 3], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 20] as array::MapArray<[T; 20], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 24]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 0] as array::MapArray<[T; 0], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 19] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 5] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 16]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 20]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 32]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 11]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 17] as array::MapArray<[T; 17], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 1]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 7] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 32] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 13] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 1] as array::MapArray<[T; 1], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 31] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 17] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 2]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 6] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 10] as array::MapArray<[T; 10], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 15] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 6]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 18] as array::MapArray<[T; 18], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 4]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 16] as array::MapArray<[T; 16], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 5]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 0] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 11] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 6] as array::MapArray<[T; 6], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 22] as array::MapArray<[T; 22], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 29]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 27]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 12] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 26]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 10] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 15]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 8] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 8] as array::MapArray<[T; 8], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 9] as array::MapArray<[T; 9], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 2] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 4] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 1] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 22]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 28] as array::MapArray<[T; 28], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 25]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 25] as array::MapArray<[T; 25], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 13]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 23] as array::MapArray<[T; 23], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 2] as array::MapArray<[T; 2], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 32] as array::MapArray<[T; 32], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 8]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 28]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 5] as array::MapArray<[T; 5], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 13] as array::MapArray<[T; 13], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 14] as array::MapArray<[T; 14], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 25] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 9] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 31]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 29] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 3] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 27] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 15] as array::MapArray<[T; 15], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 26] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 17]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 31] as array::MapArray<[T; 31], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 21] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 24] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 21]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 18] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 16] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 30]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 11] as array::MapArray<[T; 11], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 30] as array::MapArray<[T; 30], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 22] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 12] as array::MapArray<[T; 12], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 9]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 7]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 19] as array::MapArray<[T; 19], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 3]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 12]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 24] as array::MapArray<[T; 24], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 10]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 28] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 14] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `<[array::Element<T>; 23] as std140::AsStd140>::std140`
-> src/array.rs:156:13: 185:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    array: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.array[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        array: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.array[i], [0m[36mself[i].0.std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.array)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/WriteFlow): Potential unsafe dataflow issue in `array::<impl std140::AsStd140 for [T; 14]>::std140`
-> src/array.rs:116:13: 145:14
fn std140(&self) -> [Element<T::Std140>; $size] {
                struct ArrayInit<T: AsStd140> where T::Std140: Sized {
                    counter: usize,
                    output: std::mem::ManuallyDrop<[Element<T::Std140>; $size]>,
                }

                impl<T: AsStd140> Drop for ArrayInit<T> where T::Std140: Sized {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }
                    }
                }

                unsafe {
                    let mut init = ArrayInit::<T> {
                        counter: 0,
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut init.output[i], [0m[36mself[i].std140()[0m[33m.into())[0m;
                        init.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *init.output)[0m;
                    std::mem::forget(init);
                    result
                }
            }
[0m
Warning (UnsafeDataflow:/ReadFlow/WriteFlow): Potential unsafe dataflow issue in `<[U; 4] as array::MapArray<[T; 4], F>>::map_array`
-> src/array.rs:70:13: 105:14
fn map_array(values: [T; $size], mut f: F) -> Self {
                struct ArrayProcess<T, U> {
                    counter: usize,
                    input: std::mem::ManuallyDrop<[T; $size]>,
                    output: std::mem::ManuallyDrop<[U; $size]>,
                }

                impl<T, U> Drop for ArrayProcess<T, U> {
                    fn drop(&mut self) {
                        for i in 0 .. self.counter {
                            unsafe { std::ptr::drop_in_place(&mut self.output[i]) }
                        }

                        for i in self.counter + 1 .. $size {
                            unsafe { std::ptr::drop_in_place(&mut self.input[i]) }
                        }
                    }
                }

                unsafe {
                    let mut process = ArrayProcess::<T, U> {
                        counter: 0,
                        input: std::mem::ManuallyDrop::new(values),
                        output: std::mem::ManuallyDrop::new(std::mem::uninitialized()),
                    };

                    for i in 0 .. $size {
                        [0m[33mstd::ptr::write(&mut process.output[i], [0m[36mf([0m[31mstd::ptr::read(&mut process.input[i])[0m[36m)[0m[33m)[0m;
                        process.counter = i + 1;
                    }

                    let result = [0m[31mstd::ptr::read(&mut *process.output)[0m;
                    std::mem::forget(process);
                    result
                }
            }
[0m
2024-06-21 17:28:47.847780 |INFO | [rudra-progress] cargo rudra finished
"
************************************
